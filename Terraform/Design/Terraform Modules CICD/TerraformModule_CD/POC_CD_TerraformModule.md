# Implementation of CD Checks on Terraform Module 

|   Author        |  Created on   |  Version   | Last updated by  | Last edited on |
| --------------- | --------------| -----------|----------------- | -------------- |
| Khushi Malhotra |  07 Feb 2024  |  Version 1 | Khushi Malhotra  | 13 Feb 2024    |

![image](https://github.com/avengers-p7/Documentation/assets/156056460/44f80ab7-909e-48c2-8b1e-ea004054137e)

## Table of Contents
- [Introduction](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#introduction)
- [Pre-requisites](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#pre-requisites)
- [Implementation of CD checks on Terraform Module](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#implementation-of-cd-checks-on-terraform-module-1)
- [Terraform Module](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#terraform-module)
- [Jenkinsfile](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#jenkinsfile)
- [Terraform groovy template file](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#terraform-groovy-template-file)
- [Shared Library src files](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#shared-library-src-files)
- [Contact Information](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#contact-information)
- [References](https://github.com/CodeOps-Hub/Documentation/blob/main/Terraform/Design/Terraform%20Modules%20CICD/TerraformModule_CD/POC_CD_TerraformModule.md#references)

## Introduction
Integrating Continuous Deployment (CD) practices into Continuous Integration/Continuous Deployment (CI/CD) pipelines for Terraform modules involves automating the deployment of infrastructure configurations.
Automated Deployment: CD in CI/CD pipelines automates the deployment of Terraform modules, ensuring that changes are applied consistently and efficiently across different environments.

## Pre-requisites

| Tool |
|------|
| Terraform |

## Implementation of CD checks on Terraform Module

![image](https://github.com/CodeOps-Hub/Documentation/assets/156056460/c56d7ed0-7db0-49ce-aeb8-d35f53a0f993)


| Tool             | Purpose                                                                                                                                                                  |
|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| terraform plan  | The `terraform plan` command is used to create an execution plan for changes to your infrastructure. It compares the current state of your infrastructure, as defined by your Terraform configuration files, with the desired state specified in those files. It then generates an execution plan that describes what Terraform will do to achieve the desired state, including which resources will be created, modified, or destroyed. However, `terraform plan` does not make any actual changes to your infrastructure; it only previews the changes that Terraform would make. This allows you to review the proposed changes before applying them to your infrastructure. |
| terraform apply | The `terraform apply` command is used to apply the changes described in the Terraform execution plan generated by `terraform plan` to your infrastructure. When you run `terraform apply`, Terraform reads the execution plan and performs the necessary actions to create, modify, or destroy resources as needed to achieve the desired state specified in your Terraform configuration files. This command actually makes changes to your infrastructure, so it sh

**Step-1** Create a New Pipeline Job

- Navigate to the Jenkins dashboard and click on New Item.
- Enter a name for your job (e.g., "Terraform.CD").
- Select Pipeline and click OK.

**Step-2** Configure Pipeline Script

- In the job configuration page, scroll down to the Pipeline section.
- Select Pipeline script from SCM.
- Give required repo url and enter your credentials.

![image](https://github.com/CodeOps-Hub/Documentation/assets/156056460/0bfd3e09-6605-4489-ae5b-0d64ca5b05f1)

![image](https://github.com/CodeOps-Hub/Documentation/assets/156056460/98b7f57a-24c5-48ac-acc2-fda4c2cc6a94)


**Step-3** Save the Configuration

- Click on Save to save the job configuration.

**Step-4** Build the Pipeline

- Once the pipeline configuration is saved, you can manually trigger the build by clicking on Build Now.

**Step-5** View Build Console Output

- After triggering the build, you can view the progress and console output of the build by clicking on the build number in the Jenkins dashboard.
- The console output will display the steps executed by the pipeline script, including code checkout and compilation.
- Verify Successful Compilation.

![image](https://github.com/CodeOps-Hub/Documentation/assets/156056460/d9849dc6-e67a-49f6-b98d-bf1a6d17c406)

![image](https://github.com/CodeOps-Hub/Documentation/assets/156056460/f8013239-2848-4271-bbf1-c52087fb89e3)

![image](https://github.com/CodeOps-Hub/Documentation/assets/156056460/c503a56d-aa9a-4b42-b58b-e4991fb4a5d6)

![image](https://github.com/CodeOps-Hub/Documentation/assets/156056460/04ee1e85-b439-4155-aa17-9b256b93b557)

<details>
<summary> Click here for Console Output</summary>
<br>

  ```shell
  Started by user khushi
Obtained SharedLibrary/Terraform_CD_JF/Jenkinsfile from git https://github.com/CodeOps-Hub/Jenkinsfile.git
Loading library shared-library@main
Attempting to resolve main from remote references...
 > git --version # timeout=10
 > git --version # 'git version 2.34.1'
using GIT_ASKPASS to set credentials khushi_pass_secret
 > git ls-remote -h -- https://github.com/CodeOps-Hub/SharedLibrary.git # timeout=10
Found match: refs/heads/main revision cbddee0f57f0d8c78c5d3c348d351e9978881830
The recommended git tool is: NONE
using credential khushi_pass_secret
 > git rev-parse --resolve-git-dir /var/lib/jenkins/workspace/terraform_module_CD@libs/9b45fc695856553d98bb823001a46a17146f4d25f13f1d010b47c5ae1c9c87b1/.git # timeout=10
Fetching changes from the remote Git repository
 > git config remote.origin.url https://github.com/CodeOps-Hub/SharedLibrary.git # timeout=10
Fetching without tags
Fetching upstream changes from https://github.com/CodeOps-Hub/SharedLibrary.git
 > git --version # timeout=10
 > git --version # 'git version 2.34.1'
using GIT_ASKPASS to set credentials khushi_pass_secret
 > git fetch --no-tags --force --progress -- https://github.com/CodeOps-Hub/SharedLibrary.git +refs/heads/*:refs/remotes/origin/* # timeout=10
Checking out Revision cbddee0f57f0d8c78c5d3c348d351e9978881830 (main)
 > git config core.sparsecheckout # timeout=10
 > git checkout -f cbddee0f57f0d8c78c5d3c348d351e9978881830 # timeout=10
Commit message: "Update deploy.groovy"
 > git rev-list --no-walk eaae312e38426559448bf0608bdf00307f0bb9aa # timeout=10
[Pipeline] Start of Pipeline
[Pipeline] properties
[Pipeline] node
Running on Jenkins in /var/lib/jenkins/workspace/terraform_module_CD
[Pipeline] {
[Pipeline] stage
[Pipeline] { (Clean Workspace)
[Pipeline] cleanWs
[WS-CLEANUP] Deleting project workspace...
[WS-CLEANUP] Deferred wipeout is used...
[WS-CLEANUP] done
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Clone)
[Pipeline] script
[Pipeline] {
[Pipeline] git
The recommended git tool is: NONE
using credential khushi_pass
Cloning the remote Git repository
Cloning repository https://github.com/khushimalhoz/terraform.git
 > git init /var/lib/jenkins/workspace/terraform_module_CD # timeout=10
Fetching upstream changes from https://github.com/khushimalhoz/terraform.git
 > git --version # timeout=10
 > git --version # 'git version 2.34.1'
using GIT_ASKPASS to set credentials khushi_pass
 > git fetch --tags --force --progress -- https://github.com/khushimalhoz/terraform.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 > git config remote.origin.url https://github.com/khushimalhoz/terraform.git # timeout=10
 > git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
 > git rev-parse refs/remotes/origin/main^{commit} # timeout=10
Checking out Revision c4ddb86606de14f4bb3cd54b7789ee7dade2fc5f (refs/remotes/origin/main)
 > git config core.sparsecheckout # timeout=10
 > git checkout -f c4ddb86606de14f4bb3cd54b7789ee7dade2fc5f # timeout=10
 > git branch -a -v --no-abbrev # timeout=10
 > git checkout -b main c4ddb86606de14f4bb3cd54b7789ee7dade2fc5f # timeout=10
Commit message: "Update variables.tf"
 > git rev-list --no-walk c4ddb86606de14f4bb3cd54b7789ee7dade2fc5f # timeout=10
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Terraform action)
[Pipeline] script
[Pipeline] {
[Pipeline] sh
+ cd Static_tf/network
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Terraform init)
[Pipeline] script
[Pipeline] {
[Pipeline] sh
+ cd Static_tf/network
+ terraform init

[0m[1mInitializing the backend...[0m

[0m[1mInitializing provider plugins...[0m
- Finding hashicorp/aws versions matching "5.38.0"...
- Installing hashicorp/aws v5.38.0...
- Installed hashicorp/aws v5.38.0 (signed by HashiCorp)

Terraform has created a lock file [1m.terraform.lock.hcl[0m to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.[0m

[0m[1m[32mTerraform has been successfully initialized![0m[32m[0m
[0m[32m
You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.[0m
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Terraform Plan)
[Pipeline] script
[Pipeline] {
[Pipeline] sh
+ cd Static_tf/network
+ terraform plan

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # aws_vpc.dev-vpc[0m will be created
[0m  [32m+[0m[0m resource "aws_vpc" "dev-vpc" {
      [32m+[0m[0m arn                                  = (known after apply)
      [32m+[0m[0m cidr_block                           = "10.0.1.0/24"
      [32m+[0m[0m default_network_acl_id               = (known after apply)
      [32m+[0m[0m default_route_table_id               = (known after apply)
      [32m+[0m[0m default_security_group_id            = (known after apply)
      [32m+[0m[0m dhcp_options_id                      = (known after apply)
      [32m+[0m[0m enable_dns_hostnames                 = false
      [32m+[0m[0m enable_dns_support                   = true
      [32m+[0m[0m enable_network_address_usage_metrics = (known after apply)
      [32m+[0m[0m id                                   = (known after apply)
      [32m+[0m[0m instance_tenancy                     = "default"
      [32m+[0m[0m ipv6_association_id                  = (known after apply)
      [32m+[0m[0m ipv6_cidr_block                      = (known after apply)
      [32m+[0m[0m ipv6_cidr_block_network_border_group = (known after apply)
      [32m+[0m[0m main_route_table_id                  = (known after apply)
      [32m+[0m[0m owner_id                             = (known after apply)
      [32m+[0m[0m tags                                 = {
          [32m+[0m[0m "Enviroment" = "dev"
          [32m+[0m[0m "Name"       = "dev-vpc"
          [32m+[0m[0m "Owner"      = "khushi"
        }
      [32m+[0m[0m tags_all                             = {
          [32m+[0m[0m "Enviroment" = "dev"
          [32m+[0m[0m "Name"       = "dev-vpc"
          [32m+[0m[0m "Owner"      = "khushi"
        }
    }

[1mPlan:[0m 1 to add, 0 to change, 0 to destroy.
[0m
Changes to Outputs:
  [32m+[0m[0m vpc-id = (known after apply)
[90m
─────────────────────────────────────────────────────────────────────────────[0m

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (Terraform Apply)
[Pipeline] script
[Pipeline] {
[Pipeline] sh
+ cd Static_tf/network
+ terraform apply -auto-approve

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # aws_vpc.dev-vpc[0m will be created
[0m  [32m+[0m[0m resource "aws_vpc" "dev-vpc" {
      [32m+[0m[0m arn                                  = (known after apply)
      [32m+[0m[0m cidr_block                           = "10.0.1.0/24"
      [32m+[0m[0m default_network_acl_id               = (known after apply)
      [32m+[0m[0m default_route_table_id               = (known after apply)
      [32m+[0m[0m default_security_group_id            = (known after apply)
      [32m+[0m[0m dhcp_options_id                      = (known after apply)
      [32m+[0m[0m enable_dns_hostnames                 = false
      [32m+[0m[0m enable_dns_support                   = true
      [32m+[0m[0m enable_network_address_usage_metrics = (known after apply)
      [32m+[0m[0m id                                   = (known after apply)
      [32m+[0m[0m instance_tenancy                     = "default"
      [32m+[0m[0m ipv6_association_id                  = (known after apply)
      [32m+[0m[0m ipv6_cidr_block                      = (known after apply)
      [32m+[0m[0m ipv6_cidr_block_network_border_group = (known after apply)
      [32m+[0m[0m main_route_table_id                  = (known after apply)
      [32m+[0m[0m owner_id                             = (known after apply)
      [32m+[0m[0m tags                                 = {
          [32m+[0m[0m "Enviroment" = "dev"
          [32m+[0m[0m "Name"       = "dev-vpc"
          [32m+[0m[0m "Owner"      = "khushi"
        }
      [32m+[0m[0m tags_all                             = {
          [32m+[0m[0m "Enviroment" = "dev"
          [32m+[0m[0m "Name"       = "dev-vpc"
          [32m+[0m[0m "Owner"      = "khushi"
        }
    }

[1mPlan:[0m 1 to add, 0 to change, 0 to destroy.
[0m
Changes to Outputs:
  [32m+[0m[0m vpc-id = (known after apply)
[0m[1maws_vpc.dev-vpc: Creating...[0m[0m
[0m[1maws_vpc.dev-vpc: Creation complete after 4s [id=vpc-02370d9be48c8b607][0m
[0m[1m[32m
Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
[0m[0m[1m[32m
Outputs:

[0mvpc-id = "vpc-02370d9be48c8b607"
[Pipeline] }
[Pipeline] // script
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
```
</details>

## [Terraform Module](https://github.com/khushimalhoz/terraform.git)

## [Jenkinsfile](https://github.com/CodeOps-Hub/Jenkinsfile/blob/main/SharedLibrary/Terraform_CD_JF/Jenkinsfile)

```shell 
@Library('shared-library') _

//import org.avengers.template.terraform.*
def terraformCD = new org.avengers.template.terraformCD.terraform_CD()
properties([
    parameters([
     //    choice(name: 'branch', choices: ['harshit/vpc', ''], description: 'Select the branch'),
    //     choice(name: 'rootDir', choices: ['Dev_Infra'], description: 'Select the root directory'),
      //   choice(name: 'childDir',choices: ['Static_Tf', 'network'], description: 'Select the child directory'),
        choice(name: 'branch', choices: ['main'], description: 'Select the branch'),
        choice(name: 'rootPath', choices: ['Static_tf'], description: 'Select the root directory'),
        choice(name: 'childPath',choices: ['network'], description: 'Select the child directory'),
    ])
])
node {
    def url = 'https://github.com/khushimalhoz/terraform.git'
  //   def url = 'https://github.com/CodeOps-Hub/Terraform.git'
    def creds = 'khushi_pass'
  //  def terraformCI = new org.avengers.template.terraform.terraformCI()
    terraformCD.call(url, creds, params.branch, params.rootPath, params.childPath)
     
}
```
## [Terraform groovy template file](https://github.com/CodeOps-Hub/SharedLibrary/blob/main/src/org/avengers/template/terraformCD/terraform_CD.groovy)
<details>
<summmary> Click here to see terraform_CD.groovy</summmary>
<br>

```shell

package org.avengers.template.terraformCD

import org.avengers.common.*
import org.avengers.terraform_CICD.*

def call(String url, String creds, String branch, String rootPath, String childPath){

    variablization = new action()
    gitCheckoutPrivate = new GitCheckoutPrivate()
    cleanWorkspace = new cleanWorkspace()
    initialization = new init()
    deploying = new deploy()
    
  

    cleanWorkspace.call()
    gitCheckoutPrivate.call(url, creds, branch)
    variablization.call(rootPath, childPath)
    initialization.call(rootPath, childPath)
    deploying.call(rootPath, childPath) 

}

```
</details>

## [Shared Library src files](https://github.com/CodeOps-Hub/SharedLibrary/tree/main/src/org/avengers/terraform_CICD)
<details>
<summary> Click here to see src files</summary>
<br>

deploy.groovy

```shell
package org.avengers.terraform_CICD

def call(String rootPath, String childPath) {
    stage("Terraform Plan") {
        script {
            sh "cd ${rootPath}/${childPath} && terraform plan"
        }
    }

    stage("Terraform Apply") {
        script {
            sh "cd ${rootPath}/${childPath} && terraform apply -auto-approve"
        }
    }
}

```
</details>

## Contact Information
| Name            | Email Address                        |
|-----------------|--------------------------------------|
| Khushi Malhotra | khushi.malhotra.snaatak@mygurukulam.co |

## References

| Description                                   | References  
| --------------------------------------------  | -------------------------------------------------|
| Terraform Module | https://spacelift.io/blog/what-are-terraform-modules-and-how-do-they-work |
| What is CD | https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment |
| Terraform Module CI/CD | https://www.reddit.com/r/Terraform/comments/17ldr9i/cicd_for_creating_terraform_modules/ |

